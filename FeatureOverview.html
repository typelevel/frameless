<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.18.1 + Helium Theme" />
    <title>TypedDataset: Feature Overview</title>
    
    
      <meta name="description" content="docs"/>
    
    
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    
    <link rel="stylesheet" type="text/css" href="helium/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="helium/laika-helium.css" />
    <script src="helium/laika-helium.js"></script>
    
    
    <script> /* for avoiding page load transitions */ </script>
  </head>

  <body>

    <header id="top-bar">

      <div class="row">
        <a id="nav-icon">
          <i class="icofont-laika" title="Navigation">&#xefa2;</i>
        </a>
        
      </div>
  
      <a class="image-link" href="https://typelevel.org"><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KCjxzdmcKICAgIHdpZHRoPSIxMjBweCIKICAgIGhlaWdodD0iNDBweCIKICAgIHZpZXdCb3g9IjAgMCAxMDU0IDM0OCIKICAgIHZlcnNpb249IjEuMSIKICAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KCiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgeDE9IjAlIiB5MT0iNjElIiB4Mj0iMTAwJSIgeTI9IjM3JSIgaWQ9ImJhY2tncm91bmQtZ3JhZGllbnQiPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRkY0QzYxIiBvZmZzZXQ9IjAlIj48L3N0b3A+CiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGNTFDMkIiIG9mZnNldD0iMTAwJSI+PC9zdG9wPgogICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICA8L2RlZnM+CgogICAgPGc+CiAgICAgICAgPHBhdGggZD0iTTQxOS43NjU3MTQsNTUuMTEwNjM4MyBMNDE5Ljc2NTcxNCwxMzMuMTI3NjYgTDM5OC41MjU3MTQsMTMzLjEyNzY2IEwzOTguNTI1NzE0LDU1LjExMDYzODMgTDM4MS4wNzg1NzEsNTUuMTEwNjM4MyBMMzgxLjA3ODU3MSwzNi45MzE5MTQ5IEw0MzcuOTcxNDI5LDM2LjkzMTkxNDkgTDQzNy45NzE0MjksNTUuMTEwNjM4MyBMNDE5Ljc2NTcxNCw1NS4xMTA2MzgzIEw0MTkuNzY1NzE0LDU1LjExMDYzODMgWiBNNDk1LjYyMjg1Nyw5OC4yODUxMDY0IEw0OTUuNjIyODU3LDEzMy4xMjc2NiBMNDc0LjM4Mjg1NywxMzMuMTI3NjYgTDQ3NC4zODI4NTcsOTguMjg1MTA2NCBMNDUwLjEwODU3MSwzNi4xNzQ0NjgxIEw0NzMuNjI0Mjg2LDM2LjE3NDQ2ODEgTDQ4NS4wMDI4NTcsNzYuMzE5MTQ4OSBMNDk2LjM4MTQyOSwzNi4xNzQ0NjgxIEw1MTkuODk3MTQzLDM2LjE3NDQ2ODEgTDQ5NS42MjI4NTcsOTguMjg1MTA2NCBMNDk1LjYyMjg1Nyw5OC4yODUxMDY0IFogTTYwMC4zMDU3MTQsNjcuMjI5Nzg3MiBDNjAwLjMwNTcxNCw3Mi41MzE5MTQ5IDU5OS41NDcxNDMsNzcuMDc2NTk1NyA1OTguMDMsODAuODYzODI5OCBDNTk2LjUxMjg1Nyw4NC42NTEwNjM4IDU5NC4yMzcxNDMsODcuNjgwODUxMSA1OTEuMjAyODU3LDkwLjcxMDYzODMgQzU4OC4xNjg1NzEsOTMuNzQwNDI1NSA1ODUuMTM0Mjg2LDk1LjI1NTMxOTEgNTgyLjEsOTYuMDEyNzY2IEM1NzkuMDY1NzE0LDk2Ljc3MDIxMjggNTc1LjI3Mjg1Nyw5Ny41Mjc2NTk2IDU3MS40OCw5Ny41Mjc2NTk2IEw1NjIuMzc3MTQzLDk3LjUyNzY1OTYgTDU2Mi4zNzcxNDMsMTMyLjM3MDIxMyBMNTQxLjEzNzE0MywxMzIuMzcwMjEzIEw1NDEuMTM3MTQzLDM2LjkzMTkxNDkgTDU3MS40OCwzNi45MzE5MTQ5IEM1NzUuMjcyODU3LDM2LjkzMTkxNDkgNTc4LjMwNzE0MywzNy42ODkzNjE3IDU4Mi4xLDM4LjQ0NjgwODUgQzU4NS44OTI4NTcsMzkuMjA0MjU1MyA1ODguOTI3MTQzLDQxLjQ3NjU5NTcgNTkxLjk2MTQyOSw0My43NDg5MzYyIEM1OTQuOTk1NzE0LDQ2LjAyMTI3NjYgNTk3LjI3MTQyOSw0OS4wNTEwNjM4IDU5OC43ODg1NzEsNTIuODM4Mjk3OSBDNTk5LjU0NzE0Myw1Ni42MjU1MzE5IDYwMC4zMDU3MTQsNjEuMTcwMjEyOCA2MDAuMzA1NzE0LDY3LjIyOTc4NzIgTDYwMC4zMDU3MTQsNjcuMjI5Nzg3MiBaIE01NzkuODI0Mjg2LDY3LjIyOTc4NzIgQzU3OS44MjQyODYsNjIuNjg1MTA2NCA1NzkuMDY1NzE0LDU5LjY1NTMxOTEgNTc2Ljc5LDU4LjE0MDQyNTUgQzU3NC41MTQyODYsNTUuODY4MDg1MSA1NzIuMjM4NTcxLDU1LjExMDYzODMgNTY5LjIwNDI4Niw1NS4xMTA2MzgzIEw1NjIuMzc3MTQzLDU1LjExMDYzODMgTDU2Mi4zNzcxNDMsODAuMTA2MzgzIEw1NjkuMjA0Mjg2LDgwLjEwNjM4MyBDNTcyLjIzODU3MSw4MC4xMDYzODMgNTc0LjUxNDI4Niw3OS4zNDg5MzYyIDU3Ni43OSw3Ny4wNzY1OTU3IEM1NzkuMDY1NzE0LDc0LjgwNDI1NTMgNTc5LjgyNDI4Niw3MS43NzQ0NjgxIDU3OS44MjQyODYsNjcuMjI5Nzg3MiBMNTc5LjgyNDI4Niw2Ny4yMjk3ODcyIFogTTYyMi4zMDQyODYsMTMzLjEyNzY2IEw2MjIuMzA0Mjg2LDM2LjkzMTkxNDkgTDY2OS4zMzU3MTQsMzYuOTMxOTE0OSBMNjY5LjMzNTcxNCw1NS44NjgwODUxIEw2NDIuNzg1NzE0LDU1Ljg2ODA4NTEgTDY0Mi43ODU3MTQsNzQuODA0MjU1MyBMNjY2LjMwMTQyOSw3NC44MDQyNTUzIEw2NjYuMzAxNDI5LDkyLjk4Mjk3ODcgTDY0Mi43ODU3MTQsOTIuOTgyOTc4NyBMNjQyLjc4NTcxNCwxMTMuNDM0MDQzIEw2NzAuMDk0Mjg2LDExMy40MzQwNDMgTDY3MC4wOTQyODYsMTMzLjEyNzY2IEw2MjIuMzA0Mjg2LDEzMy4xMjc2NiBMNjIyLjMwNDI4NiwxMzMuMTI3NjYgWiBNNjk2LjY0NDI4NiwxMzMuMTI3NjYgTDY5Ni42NDQyODYsMzYuOTMxOTE0OSBMNzE4LjY0Mjg1NywzNi45MzE5MTQ5IEw3MTguNjQyODU3LDExMy40MzQwNDMgTDc0NC40MzQyODYsMTEzLjQzNDA0MyBMNzQ0LjQzNDI4NiwxMzMuODg1MTA2IEw2OTYuNjQ0Mjg2LDEzMy44ODUxMDYgTDY5Ni42NDQyODYsMTMzLjEyNzY2IFogTTc2Ny45NSwxMzMuMTI3NjYgTDc2Ny45NSwzNi45MzE5MTQ5IEw4MTQuOTgxNDI5LDM2LjkzMTkxNDkgTDgxNC45ODE0MjksNTUuODY4MDg1MSBMNzg5LjE5LDU1Ljg2ODA4NTEgTDc4OS4xOSw3NC44MDQyNTUzIEw4MTIuNzA1NzE0LDc0LjgwNDI1NTMgTDgxMi43MDU3MTQsOTIuOTgyOTc4NyBMNzg5LjE5LDkyLjk4Mjk3ODcgTDc4OS4xOSwxMTMuNDM0MDQzIEw4MTYuNDk4NTcxLDExMy40MzQwNDMgTDgxNi40OTg1NzEsMTMzLjEyNzY2IEw3NjcuOTUsMTMzLjEyNzY2IEw3NjcuOTUsMTMzLjEyNzY2IFogTTg4NS41Mjg1NzEsMTMzLjEyNzY2IEw4NTcuNDYxNDI5LDEzMy4xMjc2NiBMODMzLjk0NTcxNCwzNi45MzE5MTQ5IEw4NTguOTc4NTcxLDM2LjkzMTkxNDkgTDg3MS44NzQyODYsMTA3LjM3NDQ2OCBMODg0Ljc3LDM2LjkzMTkxNDkgTDkwOC4yODU3MTQsMzYuOTMxOTE0OSBMODg1LjUyODU3MSwxMzMuMTI3NjYgTDg4NS41Mjg1NzEsMTMzLjEyNzY2IFogTTkzMS4wNDI4NTcsMTMzLjEyNzY2IEw5MzEuMDQyODU3LDM2LjkzMTkxNDkgTDk3OC4wNzQyODYsMzYuOTMxOTE0OSBMOTc4LjA3NDI4Niw1NS44NjgwODUxIEw5NTIuMjgyODU3LDU1Ljg2ODA4NTEgTDk1Mi4yODI4NTcsNzQuODA0MjU1MyBMOTc1Ljc5ODU3MSw3NC44MDQyNTUzIEw5NzUuNzk4NTcxLDkyLjk4Mjk3ODcgTDk1Mi4yODI4NTcsOTIuOTgyOTc4NyBMOTUyLjI4Mjg1NywxMTMuNDM0MDQzIEw5NzkuNTkxNDI5LDExMy40MzQwNDMgTDk3OS41OTE0MjksMTMzLjEyNzY2IEw5MzEuMDQyODU3LDEzMy4xMjc2NiBMOTMxLjA0Mjg1NywxMzMuMTI3NjYgWiBNMTAwNi4xNDE0MywxMzMuMTI3NjYgTDEwMDYuMTQxNDMsMzYuOTMxOTE0OSBMMTAyOC4xNCwzNi45MzE5MTQ5IEwxMDI4LjE0LDExMy40MzQwNDMgTDEwNTMuOTMxNDMsMTEzLjQzNDA0MyBMMTA1My45MzE0MywxMzMuODg1MTA2IEwxMDA2LjE0MTQzLDEzMy44ODUxMDYgTDEwMDYuMTQxNDMsMTMzLjEyNzY2IFogTTQyOS42MjcxNDMsMjMzLjg2ODA4NSBDNDI4LjExLDIzMS41OTU3NDUgNDI1LjgzNDI4NiwyMzAuODM4Mjk4IDQyMy41NTg1NzEsMjI5LjMyMzQwNCBDNDIxLjI4Mjg1NywyMjguNTY1OTU3IDQxOS4wMDcxNDMsMjI3LjgwODUxMSA0MTYuNzMxNDI5LDIyNy44MDg1MTEgQzQxNC40NTU3MTQsMjI3LjgwODUxMSA0MTIuMTgsMjI4LjU2NTk1NyA0MDkuOTA0Mjg2LDIzMC4wODA4NTEgQzQwNy42Mjg1NzEsMjMxLjU5NTc0NSA0MDYuODcsMjMzLjg2ODA4NSA0MDYuODcsMjM3LjY1NTMxOSBDNDA2Ljg3LDI0MC42ODUxMDYgNDA3LjYyODU3MSwyNDIuOTU3NDQ3IDQwOS45MDQyODYsMjQ0LjQ3MjM0IEM0MTIuMTgsMjQ1Ljk4NzIzNCA0MTUuMjE0Mjg2LDI0OC4yNTk1NzQgNDE5LjAwNzE0MywyNDkuNzc0NDY4IEM0MjEuMjgyODU3LDI1MC41MzE5MTUgNDIzLjU1ODU3MSwyNTIuMDQ2ODA5IDQyNS44MzQyODYsMjUzLjU2MTcwMiBDNDI4LjExLDI1NS4wNzY1OTYgNDMwLjM4NTcxNCwyNTYuNTkxNDg5IDQzMi42NjE0MjksMjU4Ljg2MzgzIEM0MzQuOTM3MTQzLDI2MS4xMzYxNyA0MzYuNDU0Mjg2LDI2My40MDg1MTEgNDM3Ljk3MTQyOSwyNjYuNDM4Mjk4IEM0MzkuNDg4NTcxLDI2OS40NjgwODUgNDQwLjI0NzE0MywyNzMuMjU1MzE5IDQ0MC4yNDcxNDMsMjc3LjA0MjU1MyBDNDQwLjI0NzE0MywyODIuMzQ0NjgxIDQzOS40ODg1NzEsMjg2Ljg4OTM2MiA0MzcuOTcxNDI5LDI5MC42NzY1OTYgQzQzNi40NTQyODYsMjk0LjQ2MzgzIDQzNC4xNzg1NzEsMjk4LjI1MTA2NCA0MzEuMTQ0Mjg2LDMwMC41MjM0MDQgQzQyOC4xMSwzMDIuNzk1NzQ1IDQyNS4wNzU3MTQsMzA1LjA2ODA4NSA0MjEuMjgyODU3LDMwNi41ODI5NzkgQzQxNy40OSwzMDguMDk3ODcyIDQxMy42OTcxNDMsMzA4Ljg1NTMxOSA0MDkuOTA0Mjg2LDMwOC44NTUzMTkgQzQwMy44MzU3MTQsMzA4Ljg1NTMxOSAzOTguNTI1NzE0LDMwOC4wOTc4NzIgMzkzLjk3NDI4NiwzMDUuODI1NTMyIEMzODkuNDIyODU3LDMwMy41NTMxOTEgMzg1LjYzLDMwMS4yODA4NTEgMzgyLjU5NTcxNCwyOTguMjUxMDY0IEwzOTMuOTc0Mjg2LDI4MS41ODcyMzQgQzM5Ni4yNSwyODMuODU5NTc0IDM5OC41MjU3MTQsMjg1LjM3NDQ2OCA0MDEuNTYsMjg2Ljg4OTM2MiBDNDA0LjU5NDI4NiwyODguNDA0MjU1IDQwNi44NywyODkuMTYxNzAyIDQwOS45MDQyODYsMjg5LjE2MTcwMiBDNDEyLjE4LDI4OS4xNjE3MDIgNDE0LjQ1NTcxNCwyODguNDA0MjU1IDQxNi43MzE0MjksMjg2Ljg4OTM2MiBDNDE4LjI0ODU3MSwyODUuMzc0NDY4IDQxOS43NjU3MTQsMjgzLjEwMjEyOCA0MTkuNzY1NzE0LDI3OS4zMTQ4OTQgQzQxOS43NjU3MTQsMjc2LjI4NTEwNiA0MTkuMDA3MTQzLDI3My4yNTUzMTkgNDE2LjczMTQyOSwyNzEuNzQwNDI2IEM0MTQuNDU1NzE0LDI3MC4yMjU1MzIgNDExLjQyMTQyOSwyNjcuOTUzMTkxIDQwNi44NywyNjUuNjgwODUxIEwzOTkuMjg0Mjg2LDI2MS4xMzYxNyBDMzk3LjAwODU3MSwyNTkuNjIxMjc3IDM5NC43MzI4NTcsMjU4LjEwNjM4MyAzOTMuMjE1NzE0LDI1NS44MzQwNDMgQzM5MS42OTg1NzEsMjUzLjU2MTcwMiAzOTAuMTgxNDI5LDI1MS4yODkzNjIgMzg5LjQyMjg1NywyNDguMjU5NTc0IEMzODguNjY0Mjg2LDI0NS4yMjk3ODcgMzg3LjkwNTcxNCwyNDIuMiAzODcuOTA1NzE0LDIzNy42NTUzMTkgQzM4Ny45MDU3MTQsMjMyLjM1MzE5MSAzODguNjY0Mjg2LDIyNy44MDg1MTEgMzkwLjk0LDIyNC4wMjEyNzcgQzM5Mi40NTcxNDMsMjIwLjIzNDA0MyAzOTQuNzMyODU3LDIxNy4yMDQyNTUgMzk3Ljc2NzE0MywyMTQuMTc0NDY4IEM0MDAuODAxNDI5LDIxMS45MDIxMjggNDAzLjgzNTcxNCwyMDkuNjI5Nzg3IDQwNy42Mjg1NzEsMjA4Ljg3MjM0IEM0MTEuNDIxNDI5LDIwNy4zNTc0NDcgNDE0LjQ1NTcxNCwyMDcuMzU3NDQ3IDQxOC4yNDg1NzEsMjA3LjM1NzQ0NyBDNDIzLjU1ODU3MSwyMDcuMzU3NDQ3IDQyOC4xMSwyMDguMTE0ODk0IDQzMi42NjE0MjksMjA5LjYyOTc4NyBDNDM3LjIxMjg1NywyMTEuMTQ0NjgxIDQ0MC4yNDcxNDMsMjEzLjQxNzAyMSA0NDMuMjgxNDI5LDIxNi40NDY4MDkgTDQyOS42MjcxNDMsMjMzLjg2ODA4NSBMNDI5LjYyNzE0MywyMzMuODY4MDg1IFogTTUxMS41NTI4NTcsMzA1LjgyNTUzMiBDNTA3LjAwMTQyOSwzMDguMDk3ODcyIDUwMS42OTE0MjksMzA5LjYxMjc2NiA0OTQuODY0Mjg2LDMwOS42MTI3NjYgQzQ4OS41NTQyODYsMzA5LjYxMjc2NiA0ODQuMjQ0Mjg2LDMwOC4wOTc4NzIgNDc5LjY5Mjg1NywzMDUuODI1NTMyIEM0NzUuMTQxNDI5LDMwMy41NTMxOTEgNDcxLjM0ODU3MSwyOTkuNzY1OTU3IDQ2Ny41NTU3MTQsMjk1LjIyMTI3NyBDNDYzLjc2Mjg1NywyOTAuNjc2NTk2IDQ2MS40ODcxNDMsMjg1LjM3NDQ2OCA0NTkuOTcsMjc5LjMxNDg5NCBDNDU4LjQ1Mjg1NywyNzMuMjU1MzE5IDQ1Ni45MzU3MTQsMjY2LjQzODI5OCA0NTYuOTM1NzE0LDI1OC44NjM4MyBDNDU2LjkzNTcxNCwyNTEuMjg5MzYyIDQ1Ny42OTQyODYsMjQ0LjQ3MjM0IDQ1OS45NywyMzguNDEyNzY2IEM0NjEuNDg3MTQzLDIzMi4zNTMxOTEgNDY0LjUyMTQyOSwyMjcuMDUxMDY0IDQ2Ny41NTU3MTQsMjIyLjUwNjM4MyBDNDcwLjU5LDIxNy45NjE3MDIgNDc1LjE0MTQyOSwyMTQuOTMxOTE1IDQ3OS42OTI4NTcsMjExLjkwMjEyOCBDNDg0LjI0NDI4NiwyMDkuNjI5Nzg3IDQ4OS41NTQyODYsMjA4LjExNDg5NCA0OTQuODY0Mjg2LDIwOC4xMTQ4OTQgQzUwMS42OTE0MjksMjA4LjExNDg5NCA1MDcuMDAxNDI5LDIwOS42Mjk3ODcgNTEwLjc5NDI4NiwyMTEuOTAyMTI4IEM1MTQuNTg3MTQzLDIxNC4xNzQ0NjggNTE4LjM4LDIxNy4yMDQyNTUgNTIxLjQxNDI4NiwyMjAuMjM0MDQzIEw1MTAuMDM1NzE0LDIzNi4xNDA0MjYgQzUwOC41MTg1NzEsMjMzLjg2ODA4NSA1MDYuMjQyODU3LDIzMi4zNTMxOTEgNTA0LjcyNTcxNCwyMzAuODM4Mjk4IEM1MDMuMjA4NTcxLDIyOS4zMjM0MDQgNTAwLjE3NDI4NiwyMjguNTY1OTU3IDQ5Ny4xNCwyMjguNTY1OTU3IEM0OTQuMTA1NzE0LDIyOC41NjU5NTcgNDkxLjgzLDIyOS4zMjM0MDQgNDg5LjU1NDI4NiwyMzAuODM4Mjk4IEM0ODcuMjc4NTcxLDIzMi4zNTMxOTEgNDg1Ljc2MTQyOSwyMzQuNjI1NTMyIDQ4NC4yNDQyODYsMjM2Ljg5Nzg3MiBDNDgyLjcyNzE0MywyMzkuOTI3NjYgNDgxLjk2ODU3MSwyNDIuOTU3NDQ3IDQ4MS4yMSwyNDYuNzQ0NjgxIEM0ODAuNDUxNDI5LDI1MC41MzE5MTUgNDgwLjQ1MTQyOSwyNTQuMzE5MTQ5IDQ4MC40NTE0MjksMjU4Ljg2MzgzIEM0ODAuNDUxNDI5LDI2My40MDg1MTEgNDgwLjQ1MTQyOSwyNjcuMTk1NzQ1IDQ4MS4yMSwyNzAuMjI1NTMyIEM0ODEuOTY4NTcxLDI3NC4wMTI3NjYgNDgyLjcyNzE0MywyNzcuMDQyNTUzIDQ4NC4yNDQyODYsMjgwLjA3MjM0IEM0ODUuNzYxNDI5LDI4My4xMDIxMjggNDg3LjI3ODU3MSwyODQuNjE3MDIxIDQ4OS41NTQyODYsMjg2LjEzMTkxNSBDNDkxLjgzLDI4Ny42NDY4MDkgNDk0LjEwNTcxNCwyODguNDA0MjU1IDQ5Ny4xNCwyODguNDA0MjU1IEM1MDAuMTc0Mjg2LDI4OC40MDQyNTUgNTAyLjQ1LDI4Ny42NDY4MDkgNTA0LjcyNTcxNCwyODYuMTMxOTE1IEM1MDcuMDAxNDI5LDI4NC42MTcwMjEgNTA4LjUxODU3MSwyODMuMTAyMTI4IDUxMC4wMzU3MTQsMjgwLjgyOTc4NyBMNTIyLjE3Mjg1NywyOTUuOTc4NzIzIEM1MTkuODk3MTQzLDMwMC41MjM0MDQgNTE2LjEwNDI4NiwzMDMuNTUzMTkxIDUxMS41NTI4NTcsMzA1LjgyNTUzMiBMNTExLjU1Mjg1NywzMDUuODI1NTMyIFogTTU4NS44OTI4NTcsMzA3LjM0MDQyNiBMNTgyLjEsMjg5LjkxOTE0OSBMNTYwLjEwMTQyOSwyODkuOTE5MTQ5IEw1NTYuMzA4NTcxLDMwNy4zNDA0MjYgTDUzNC4zMSwzMDcuMzQwNDI2IEw1NTcuODI1NzE0LDIxMS4xNDQ2ODEgTDU4NS4xMzQyODYsMjExLjE0NDY4MSBMNjA4LjY1LDMwNy4zNDA0MjYgTDU4NS44OTI4NTcsMzA3LjM0MDQyNiBMNTg1Ljg5Mjg1NywzMDcuMzQwNDI2IFogTTU3MS40OCwyMzEuNTk1NzQ1IEw1NjIuMzc3MTQzLDI3Mi40OTc4NzIgTDU3OS4wNjU3MTQsMjcyLjQ5Nzg3MiBMNTcxLjQ4LDIzMS41OTU3NDUgTDU3MS40OCwyMzEuNTk1NzQ1IFogTTYzMC42NDg1NzEsMzA3LjM0MDQyNiBMNjMwLjY0ODU3MSwyMTEuMTQ0NjgxIEw2NTIuNjQ3MTQzLDIxMS4xNDQ2ODEgTDY1Mi42NDcxNDMsMjg3LjY0NjgwOSBMNjc4LjQzODU3MSwyODcuNjQ2ODA5IEw2NzguNDM4NTcxLDMwOC4wOTc4NzIgTDYzMC42NDg1NzEsMzA4LjA5Nzg3MiBMNjMwLjY0ODU3MSwzMDcuMzQwNDI2IFogTTc0NS4xOTI4NTcsMzA3LjM0MDQyNiBMNzQxLjQsMjg5LjkxOTE0OSBMNzE5LjQwMTQyOSwyODkuOTE5MTQ5IEw3MTUuNjA4NTcxLDMwNy4zNDA0MjYgTDY5My42MSwzMDcuMzQwNDI2IEw3MTcuMTI1NzE0LDIxMS4xNDQ2ODEgTDc0NC40MzQyODYsMjExLjE0NDY4MSBMNzY3Ljk1LDMwNy4zNDA0MjYgTDc0NS4xOTI4NTcsMzA3LjM0MDQyNiBMNzQ1LjE5Mjg1NywzMDcuMzQwNDI2IFogTTczMC4wMjE0MjksMjMxLjU5NTc0NSBMNzIwLjkxODU3MSwyNzIuNDk3ODcyIEw3MzcuNjA3MTQzLDI3Mi40OTc4NzIgTDczMC4wMjE0MjksMjMxLjU5NTc0NSBMNzMwLjAyMTQyOSwyMzEuNTk1NzQ1IFoiIGZpbGw9IiMyMTMwM0YiIC8+CgogICAgICAgIDxnIGlkPSJsb2dvIj4KICAgICAgICAgICAgPHBvbHlnb24gZmlsbD0idXJsKCNiYWNrZ3JvdW5kLWdyYWRpZW50KSIgcG9pbnRzPSIxNTEgMzQ4IDAgMjYwIDAgODggMTUxIDAgMzAyIDg4IDMwMiAyNjAiIC8+CiAgICAgICAgICAgIDxwb2x5Z29uIGZpbGw9IiNGRjYxNjkiIHBvaW50cz0iOTkgMjE0IDk5IDI1NCAxOTMgMTk5IDE5MyAxNTkiIC8+CiAgICAgICAgICAgIDxwb2x5Z29uIGZpbGw9IiNGRjYxNjkiIHBvaW50cz0iMTM0IDE5NCA5OSAxNzQgMTkzIDExOSAyMjggMTM5IiAvPgogICAgICAgICAgICA8cG9seWdvbiBmaWxsPSIjRkY2MTY5IiBwb2ludHM9Ijk5IDEzNCA2NCAxMTQgMTU4IDU5IDE5MyA3OSIgLz4KICAgICAgICAgICAgPHBvbHlnb24gZmlsbD0iI0ZGQjRCNSIgcG9pbnRzPSIxMzQgMTk0IDEzNCAyMzQgMjI4IDE3OSAyMjggMTM5IiAvPgogICAgICAgICAgICA8cG9seWdvbiBmaWxsPSIjRkZCNEI1IiBwb2ludHM9Ijk5IDEzNCA5OSAxNzQgMTkzIDExOSAxOTMgNzkiIC8+CiAgICAgICAgICAgIDxwb2x5Z29uIGZpbGw9IiNGRkZGRkYiIHBvaW50cz0iNjQgMjM0IDk5IDI1NCA5OSAyMTQgMTM0IDIzNCAxMzQgMTk0IDk5IDE3NCA5OSAxMzQgNjQgMTE0IiAvPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+Cg=="></a>
      
      <span class="row links"><a class="icon-link svg-link" href="https://github.com/typelevel/frameless"><span title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a><a class="icon-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika" title="Chat">&#xeed5;</i></a><a class="icon-link" href="https://twitter.com/typelevel"><i class="icofont-laika" title="Twitter">&#xed7a;</i></a></span>
      
    </header>

    <nav id="sidebar">

      <div class="row">
        <a class="icon-link svg-link" href="https://github.com/typelevel/frameless"><span title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a><a class="icon-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika" title="Chat">&#xeed5;</i></a><a class="icon-link" href="https://twitter.com/typelevel"><i class="icofont-laika" title="Twitter">&#xed7a;</i></a>
      </div>
      
      <ul class="nav-list">
        <li class="level1 active"><a href="#">TypedDataset: Feature Overview</a></li>
        <li class="level1"><a href="TypedDatasetVsSparkDataset.html">Comparing TypedDatasets with Spark&#39;s Datasets</a></li>
        <li class="level1"><a href="WorkingWithCsvParquetJson.html">Working with CSV and Parquet data</a></li>
        <li class="level1"><a href="Injection.html">Injection: Creating Custom Encoders</a></li>
        <li class="level1"><a href="Job.html">Job[A]</a></li>
        <li class="level1"><a href="Cats.html">Using Cats with Frameless</a></li>
        <li class="level1"><a href="TypedML.html">Typed Spark ML</a></li>
        <li class="level1"><a href="TypedDataFrame.html">Proof of Concept: TypedDataFrame</a></li>
        <li class="level1"><a href="TypedEncoder.html">Typed Encoders in Frameless</a></li>
      </ul>
      
    </nav>

    <div id="container">

      <nav id="page-nav">
        <p class="header"><a href="#">TypedDataset: Feature Overview</a></p>
        
        <ul class="nav-list">
          <li class="level1"><a href="#creating-typeddataset-instances">Creating TypedDataset instances</a></li>
          <li class="level1"><a href="#typesafe-column-referencing">Typesafe column referencing</a></li>
          <li class="level1"><a href="#working-with-optional-columns">Working with Optional columns</a></li>
          <li class="level1"><a href="#casting-and-projections">Casting and projections</a></li>
          <li class="level2"><a href="#advanced-topics-with-select">Advanced topics with <code>select()</code></a></li>
          <li class="level2"><a href="#projections">Projections</a></li>
          <li class="level2"><a href="#union-of-typeddatasets">Union of TypedDatasets</a></li>
          <li class="level1"><a href="#typeddataset-functions-and-transformations">TypedDataset functions and transformations</a></li>
          <li class="level2"><a href="#drop-replace-add-fields">Drop/Replace/Add fields</a></li>
          <li class="level2"><a href="#working-with-collections">Working with collections</a></li>
          <li class="level2"><a href="#collecting-data-to-the-driver">Collecting data to the driver</a></li>
          <li class="level1"><a href="#sorting-columns">Sorting columns</a></li>
          <li class="level1"><a href="#user-defined-functions">User Defined Functions</a></li>
          <li class="level1"><a href="#groupby-and-aggregations">GroupBy and Aggregations</a></li>
          <li class="level2"><a href="#working-with-optional-fields">Working with Optional fields</a></li>
          <li class="level2"><a href="#entire-typeddataset-aggregation">Entire TypedDataset Aggregation</a></li>
          <li class="level1"><a href="#joins">Joins</a></li>
        </ul>
        
        <p class="footer"></p>
      </nav>

      <main class="content">

        <h1 id="typeddataset-feature-overview" class="title">TypedDataset: Feature Overview</h1>
        <p>This tutorial introduces <code>TypedDataset</code> using a simple example.
        The following imports are needed to make all code examples compile.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">org</span><span>.</span><span class="identifier">apache</span><span>.</span><span class="identifier">spark</span><span>.{</span><span class="type-name">SparkConf</span><span>, </span><span class="type-name">SparkContext</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">org</span><span>.</span><span class="identifier">apache</span><span>.</span><span class="identifier">spark</span><span>.</span><span class="identifier">sql</span><span>.</span><span class="type-name">SparkSession</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="identifier">functions</span><span>.</span><span class="identifier">aggregate</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="type-name">TypedDataset</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">conf</span><span> = </span><span class="keyword">new</span><span> </span><span class="type-name">SparkConf</span><span>().</span><span class="identifier">setMaster</span><span>(</span><span class="string-literal">&quot;local[*]&quot;</span><span>).</span><span class="identifier">setAppName</span><span>(</span><span class="string-literal">&quot;Frameless repl&quot;</span><span>).</span><span class="identifier">set</span><span>(</span><span class="string-literal">&quot;spark.ui.enabled&quot;</span><span>, </span><span class="string-literal">&quot;false&quot;</span><span>)
</span><span class="keyword">implicit</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">spark</span><span> = </span><span class="type-name">SparkSession</span><span>.</span><span class="identifier">builder</span><span>().</span><span class="identifier">config</span><span>(</span><span class="identifier">conf</span><span>).</span><span class="identifier">appName</span><span>(</span><span class="string-literal">&quot;REPL&quot;</span><span>).</span><span class="identifier">getOrCreate</span><span>()
</span><span class="identifier">spark</span><span>.</span><span class="identifier">sparkContext</span><span>.</span><span class="identifier">setLogLevel</span><span>(</span><span class="string-literal">&quot;WARN&quot;</span><span>)

</span><span class="keyword">import</span><span> </span><span class="identifier">spark</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">_</span></code></pre>
        
        <h2 id="creating-typeddataset-instances" class="section">Creating TypedDataset instances<a class="anchor-link right" href="#creating-typeddataset-instances"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>We start by defining a case class:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Apartment</span><span>(</span><span class="identifier">city</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">surface</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">price</span><span>: </span><span class="type-name">Double</span><span>, </span><span class="identifier">bedrooms</span><span>: </span><span class="type-name">Int</span><span>)</span></code></pre>
        <p>And few <code>Apartment</code> instances:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">apartments</span><span> = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">Apartment</span><span>(</span><span class="string-literal">&quot;Paris&quot;</span><span>, </span><span class="number-literal">50</span><span>,  </span><span class="number-literal">300000.0</span><span>, </span><span class="number-literal">2</span><span>),
  </span><span class="type-name">Apartment</span><span>(</span><span class="string-literal">&quot;Paris&quot;</span><span>, </span><span class="number-literal">100</span><span>, </span><span class="number-literal">450000.0</span><span>, </span><span class="number-literal">3</span><span>),
  </span><span class="type-name">Apartment</span><span>(</span><span class="string-literal">&quot;Paris&quot;</span><span>, </span><span class="number-literal">25</span><span>,  </span><span class="number-literal">250000.0</span><span>, </span><span class="number-literal">1</span><span>),
  </span><span class="type-name">Apartment</span><span>(</span><span class="string-literal">&quot;Lyon&quot;</span><span>,  </span><span class="number-literal">83</span><span>,  </span><span class="number-literal">200000.0</span><span>, </span><span class="number-literal">2</span><span>),
  </span><span class="type-name">Apartment</span><span>(</span><span class="string-literal">&quot;Lyon&quot;</span><span>,  </span><span class="number-literal">45</span><span>,  </span><span class="number-literal">133000.0</span><span>, </span><span class="number-literal">1</span><span>),
  </span><span class="type-name">Apartment</span><span>(</span><span class="string-literal">&quot;Nice&quot;</span><span>,  </span><span class="number-literal">74</span><span>,  </span><span class="number-literal">325000.0</span><span>, </span><span class="number-literal">3</span><span>)
)</span></code></pre>
        <p>We are now ready to instantiate a <code>TypedDataset[Apartment]</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">aptTypedDs</span><span> = </span><span class="type-name">TypedDataset</span><span>.</span><span class="identifier">create</span><span>(</span><span class="identifier">apartments</span><span>)
</span><span class="comment">// aptTypedDs: TypedDataset[Apartment] = [city: string, surface: int ... 2 more fields]</span></code></pre>
        <p>We can also create one from an existing Spark <code>Dataset</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">aptDs</span><span> = </span><span class="identifier">spark</span><span>.</span><span class="identifier">createDataset</span><span>(</span><span class="identifier">apartments</span><span>)
</span><span class="comment">// aptDs: org.apache.spark.sql.Dataset[Apartment] = [city: string, surface: int ... 2 more fields]
</span><span class="keyword">val</span><span> </span><span class="identifier">aptTypedDs</span><span> = </span><span class="type-name">TypedDataset</span><span>.</span><span class="identifier">create</span><span>(</span><span class="identifier">aptDs</span><span>)
</span><span class="comment">// aptTypedDs: TypedDataset[Apartment] = [city: string, surface: int ... 2 more fields]</span></code></pre>
        <p>Or use the Frameless syntax:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">aptTypedDs2</span><span> = </span><span class="identifier">aptDs</span><span>.</span><span class="identifier">typed</span><span>
</span><span class="comment">// aptTypedDs2: TypedDataset[Apartment] = [city: string, surface: int ... 2 more fields]</span></code></pre>
        
        <h2 id="typesafe-column-referencing" class="section">Typesafe column referencing<a class="anchor-link right" href="#typesafe-column-referencing"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>This is how we select a particular column from a <code>TypedDataset</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">cities</span><span>: </span><span class="type-name">TypedDataset</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>))
</span><span class="comment">// cities: TypedDataset[String] = [value: string]</span></code></pre>
        <p>This is completely type-safe, for instance suppose we misspell <code>city</code> as <code>citi</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;citi</span><span>))
</span><span class="comment">// error: No column Symbol with shapeless.tag.Tagged[String(&quot;citi&quot;)] of type A in repl.MdocSession.App0.Apartment
// aptTypedDs.select(aptTypedDs(&#39;citi))
//                             ^</span></code></pre>
        <p>This gets raised at compile time, whereas with the standard <code>Dataset</code> API the error appears at runtime (enjoy the stack trace):</p>
        <pre><code class="nohighlight"><span class="identifier">aptDs</span><span>.</span><span class="identifier">select</span><span>(</span><span class="symbol-literal">&#39;citi</span><span>)
</span><span class="comment">// org.apache.spark.sql.AnalysisException: cannot resolve &#39;citi&#39; given input columns: [bedrooms, city, price, surface];
// &#39;Project [&#39;citi]
// +- LocalRelation [city#64, surface#65, price#66, bedrooms#67]
// 
// 	at org.apache.spark.sql.catalyst.analysis.package$AnalysisErrorAt.failAnalysis(package.scala:54)
// 	at org.apache.spark.sql.catalyst.analysis.CheckAnalysis$$anonfun$$nestedInanonfun$checkAnalysis$1$2.applyOrElse(CheckAnalysis.scala:179)
// 	at org.apache.spark.sql.catalyst.analysis.CheckAnalysis$$anonfun$$nestedInanonfun$checkAnalysis$1$2.applyOrElse(CheckAnalysis.scala:175)
// 	at org.apache.spark.sql.catalyst.trees.TreeNode.$anonfun$transformUpWithPruning$2(TreeNode.scala:535)
// 	at org.apache.spark.sql.catalyst.trees.CurrentOrigin$.withOrigin(TreeNode.scala:82)
// 	at org.apache.spark.sql.catalyst.trees.TreeNode.transformUpWithPruning(TreeNode.scala:535)
// 	at org.apache.spark.sql.catalyst.plans.QueryPlan.$anonfun$transformExpressionsUpWithPruning$1(QueryPlan.scala:181)
// 	at org.apache.spark.sql.catalyst.plans.QueryPlan.$anonfun$mapExpressions$1(QueryPlan.scala:193)
// 	at org.apache.spark.sql.catalyst.trees.CurrentOrigin$.withOrigin(TreeNode.scala:82)
// 	at org.apache.spark.sql.catalyst.plans.QueryPlan.transformExpression$1(QueryPlan.scala:193)
// 	at org.apache.spark.sql.catalyst.plans.QueryPlan.recursiveTransform$1(QueryPlan.scala:204)
// 	at org.apache.spark.sql.catalyst.plans.QueryPlan.$anonfun$mapExpressions$3(QueryPlan.scala:209)
// 	at scala.collection.TraversableLike.$anonfun$map$1(TraversableLike.scala:286)
// 	at scala.collection.mutable.ResizableArray.foreach(ResizableArray.scala:62)
// 	at scala.collection.mutable.ResizableArray.foreach$(ResizableArray.scala:55)
// 	at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:49)
// 	at scala.collection.TraversableLike.map(TraversableLike.scala:286)
// 	at scala.collection.TraversableLike.map$(TraversableLike.scala:279)
// 	at scala.collection.AbstractTraversable.map(Traversable.scala:108)
// 	at org.apache.spark.sql.catalyst.plans.QueryPlan.recursiveTransform$1(QueryPlan.scala:209)
// 	at org.apache.spark.sql.catalyst.plans.QueryPlan.$anonfun$mapExpressions$4(QueryPlan.scala:214)
// 	at org.apache.spark.sql.catalyst.trees.TreeNode.mapProductIterator(TreeNode.scala:323)
// 	at org.apache.spark.sql.catalyst.plans.QueryPlan.mapExpressions(QueryPlan.scala:214)
// 	at org.apache.spark.sql.catalyst.plans.QueryPlan.transformExpressionsUpWithPruning(QueryPlan.scala:181)
// 	at org.apache.spark.sql.catalyst.plans.QueryPlan.transformExpressionsUp(QueryPlan.scala:161)
// 	at org.apache.spark.sql.catalyst.analysis.CheckAnalysis.$anonfun$checkAnalysis$1(CheckAnalysis.scala:175)
// 	at org.apache.spark.sql.catalyst.analysis.CheckAnalysis.$anonfun$checkAnalysis$1$adapted(CheckAnalysis.scala:94)
// 	at org.apache.spark.sql.catalyst.trees.TreeNode.foreachUp(TreeNode.scala:263)
// 	at org.apache.spark.sql.catalyst.analysis.CheckAnalysis.checkAnalysis(CheckAnalysis.scala:94)
// 	at org.apache.spark.sql.catalyst.analysis.CheckAnalysis.checkAnalysis$(CheckAnalysis.scala:91)
// 	at org.apache.spark.sql.catalyst.analysis.Analyzer.checkAnalysis(Analyzer.scala:182)
// 	at org.apache.spark.sql.catalyst.analysis.Analyzer.$anonfun$executeAndCheck$1(Analyzer.scala:205)
// 	at org.apache.spark.sql.catalyst.plans.logical.AnalysisHelper$.markInAnalyzer(AnalysisHelper.scala:330)
// 	at org.apache.spark.sql.catalyst.analysis.Analyzer.executeAndCheck(Analyzer.scala:202)
// 	at org.apache.spark.sql.execution.QueryExecution.$anonfun$analyzed$1(QueryExecution.scala:88)
// 	at org.apache.spark.sql.catalyst.QueryPlanningTracker.measurePhase(QueryPlanningTracker.scala:111)
// 	at org.apache.spark.sql.execution.QueryExecution.$anonfun$executePhase$1(QueryExecution.scala:196)
// 	at org.apache.spark.sql.SparkSession.withActive(SparkSession.scala:775)
// 	at org.apache.spark.sql.execution.QueryExecution.executePhase(QueryExecution.scala:196)
// 	at org.apache.spark.sql.execution.QueryExecution.analyzed$lzycompute(QueryExecution.scala:88)
// 	at org.apache.spark.sql.execution.QueryExecution.analyzed(QueryExecution.scala:86)
// 	at org.apache.spark.sql.execution.QueryExecution.assertAnalyzed(QueryExecution.scala:78)
// 	at org.apache.spark.sql.Dataset$.$anonfun$ofRows$1(Dataset.scala:90)
// 	at org.apache.spark.sql.SparkSession.withActive(SparkSession.scala:775)
// 	at org.apache.spark.sql.Dataset$.ofRows(Dataset.scala:88)
// 	at org.apache.spark.sql.Dataset.withPlan(Dataset.scala:3734)
// 	at org.apache.spark.sql.Dataset.select(Dataset.scala:1454)
// 	at repl.MdocSession$App0$$anonfun$25.apply(FeatureOverview.md:95)
// 	at repl.MdocSession$App0$$anonfun$25.apply(FeatureOverview.md:95)</span></code></pre>
        <p><code>select()</code> supports arbitrary column operations:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>) * </span><span class="number-literal">10</span><span>, </span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>) + </span><span class="number-literal">2</span><span>).</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// +----+---+
// |  _1| _2|
// +----+---+
// | 500| 52|
// |1000|102|
// | 250| 27|
// | 830| 85|
// | 450| 47|
// | 740| 76|
// +----+---+
//</span></code></pre>
        <p>Note that unlike the standard Spark API, where some operations are lazy and some are not, <strong>all TypedDatasets operations are lazy.</strong>
        In the above example, <code>show()</code> is lazy. It requires to apply <code>run()</code> for the <code>show</code> job to materialize.
        A more detailed explanation of <code>Job</code> is given <a href="Job.html">here</a>.</p>
        <p>Next we compute the price by surface unit:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">priceBySurfaceUnit</span><span> = </span><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;price</span><span>) / </span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>))
</span><span class="comment">// error: overloaded method value / with alternatives:
//   (u: Double)(implicit n: frameless.CatalystNumeric[Double])frameless.TypedColumn[repl.MdocSession.App0.Apartment,Double] &lt;and&gt;
//   [Out, TT, W](other: frameless.TypedColumn[TT,Double])(implicit n: frameless.CatalystDivisible[Double,Out], implicit e: frameless.TypedEncoder[Out], implicit w: frameless.With[repl.MdocSession.App0.Apartment,TT]{type Out = W})frameless.TypedColumn[W,Out]
//  cannot be applied to (frameless.TypedColumn[repl.MdocSession.App0.Apartment,Int])
// val priceBySurfaceUnit = aptTypedDs.select(aptTypedDs(&#39;price) / aptTypedDs(&#39;surface).cast[Double])
//                                            ^^^^^^^^^^^^^^^^^^^^</span></code></pre>
        <p>As the error suggests, we can&#39;t divide a <code>TypedColumn</code> of <code>Double</code> by <code>Int.</code>
        For safety, in Frameless only math operations between same types is allowed:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">priceBySurfaceUnit</span><span> = </span><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;price</span><span>) / </span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>).</span><span class="identifier">cast</span><span>[</span><span class="type-name">Double</span><span>])
</span><span class="comment">// priceBySurfaceUnit: TypedDataset[Double] = [value: double]
</span><span class="identifier">priceBySurfaceUnit</span><span>.</span><span class="identifier">collect</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// res5: Seq[Double] = WrappedArray(
//   6000.0,
//   4500.0,
//   10000.0,
//   2409.6385542168673,
//   2955.5555555555557,
//   4391.891891891892
// )</span></code></pre>
        <p>Looks like it worked, but that <code>cast</code> seems unsafe right? Actually it is safe.
        Let&#39;s try to cast a <code>TypedColumn</code> of <code>String</code> to <code>Double</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>).</span><span class="identifier">cast</span><span>[</span><span class="type-name">Double</span><span>]
</span><span class="comment">// error: could not find implicit value for parameter c: frameless.CatalystCast[String,Double]
// val updated = aptTypedDs.select(aptTypedDs(&#39;city), aptTypedDs(&#39;surface) + 2).as[UpdatedSurface]
//               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre>
        <p>The compile-time error tells us that to perform the cast, an evidence
        (in the form of <code>CatalystCast[String, Double]</code>) must be available.
        Since casting from <code>String</code> to <code>Double</code> is not allowed, this results
        in a compilation error.</p>
        <p>Check <a href="https://github.com/typelevel/frameless/blob/master/core/src/main/scala/frameless/CatalystCast.scala">here</a>
        for the set of available <code>CatalystCast.</code></p>
        
        <h2 id="working-with-optional-columns" class="section">Working with Optional columns<a class="anchor-link right" href="#working-with-optional-columns"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>When working with real data we have to deal with imperfections, such as missing fields. Columns that may have
        missing data should be represented using <code>Options</code>. For this example, let&#39;s assume that the Apartments dataset
        may have missing values.<br></p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ApartmentOpt</span><span>(</span><span class="identifier">city</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>], </span><span class="identifier">surface</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">Int</span><span>], </span><span class="identifier">price</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">Double</span><span>], </span><span class="identifier">bedrooms</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">Int</span><span>])</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">apartmentsOpt</span><span> = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">ApartmentOpt</span><span>(</span><span class="type-name">Some</span><span>(</span><span class="string-literal">&quot;Paris&quot;</span><span>), </span><span class="type-name">Some</span><span>(</span><span class="number-literal">50</span><span>),  </span><span class="type-name">Some</span><span>(</span><span class="number-literal">300000.0</span><span>), </span><span class="type-name">None</span><span>),
  </span><span class="type-name">ApartmentOpt</span><span>(</span><span class="type-name">None</span><span>, </span><span class="type-name">None</span><span>, </span><span class="type-name">Some</span><span>(</span><span class="number-literal">450000.0</span><span>), </span><span class="type-name">Some</span><span>(</span><span class="number-literal">3</span><span>))
)</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">aptTypedDsOpt</span><span> = </span><span class="type-name">TypedDataset</span><span>.</span><span class="identifier">create</span><span>(</span><span class="identifier">apartmentsOpt</span><span>)
</span><span class="comment">// aptTypedDsOpt: TypedDataset[ApartmentOpt] = [city: string, surface: int ... 2 more fields]
</span><span class="identifier">aptTypedDsOpt</span><span>.</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+-------+--------+--------+
// | city|surface|   price|bedrooms|
// +-----+-------+--------+--------+
// |Paris|     50|300000.0|    null|
// | null|   null|450000.0|       3|
// +-----+-------+--------+--------+
//</span></code></pre>
        <p>Unfortunately the syntax used above with <code>select()</code> will not work here:</p>
        <pre><code class="nohighlight"><span class="identifier">aptTypedDsOpt</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptTypedDsOpt</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>) * </span><span class="number-literal">10</span><span>, </span><span class="identifier">aptTypedDsOpt</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>) + </span><span class="number-literal">2</span><span>).</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// error: overloaded method value * with alternatives:
//   (u: Option[Int])(implicit n: frameless.CatalystNumeric[Option[Int]])frameless.TypedColumn[ApartmentOpt,Option[Int]] &lt;and&gt;
//   [TT, W](other: frameless.TypedColumn[TT,Option[Int]])(implicit n: frameless.CatalystNumeric[Option[Int]], implicit w: frameless.With[ApartmentOpt,TT]{type Out = W}, implicit t: scala.reflect.ClassTag[Option[Int]])frameless.TypedColumn[W,Option[Int]]
//  cannot be applied to (Int)
// aptTypedDsOpt.select(aptTypedDsOpt(&#39;surface) * 10, aptTypedDsOpt(&#39;surface) + 2).show().run()
//                      ^^^^^^^^^^^^^^^^^^^^^^^^^
// error: overloaded method value + with alternatives:
//   (u: Option[Int])(implicit n: frameless.CatalystNumeric[Option[Int]])frameless.TypedColumn[ApartmentOpt,Option[Int]] &lt;and&gt;
//   [TT, W](other: frameless.TypedColumn[TT,Option[Int]])(implicit n: frameless.CatalystNumeric[Option[Int]], implicit w: frameless.With[ApartmentOpt,TT]{type Out = W})frameless.TypedColumn[W,Option[Int]]
//  cannot be applied to (Int)
// aptTypedDsOpt.select(aptTypedDsOpt(&#39;surface) * 10, aptTypedDsOpt(&#39;surface) + 2).show().run()
//                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre>
        <p>This is because we cannot multiple an <code>Option</code> with an <code>Int</code>. In Scala, <code>Option</code> has a <code>map()</code> method to help address
        exactly this (e.g., <code>Some(10).map(c =&gt; c * 2)</code>). Frameless follows a similar convention. By applying the <code>opt</code> method on 
        any <code>Option[X]</code> column you can then use <code>map()</code> to provide a function that works with the unwrapped type <code>X</code>. 
        This is best shown in the example bellow:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDsOpt</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptTypedDsOpt</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>).</span><span class="identifier">opt</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">c</span><span> =&gt; </span><span class="identifier">c</span><span> * </span><span class="number-literal">10</span><span>), </span><span class="identifier">aptTypedDsOpt</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>).</span><span class="identifier">opt</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">_</span><span> + </span><span class="number-literal">2</span><span>)).</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()</span></code></pre>
        <p><strong>Known issue</strong>: <code>map()</code> will throw a runtime exception when the applied function includes a <code>udf()</code>. If you want to 
        apply a <code>udf()</code> to an optional column, we recommend changing your <code>udf</code> to work directly with <code>Optional</code> fields. </p>
        
        <h2 id="casting-and-projections" class="section">Casting and projections<a class="anchor-link right" href="#casting-and-projections"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>In the general case, <code>select()</code> returns a TypedDataset of type <code>TypedDataset[TupleN[...]]</code> (with N in <code>[1...10]</code>).
        For example, if we select three columns with types <code>String</code>, <code>Int</code>, and <code>Boolean</code> the result will have type
        <code>TypedDataset[(String, Int, Boolean)]</code>. </p>
        <p>We often want to give more expressive types to the result of our computations.
        <code>as[T]</code> allows us to safely cast a <code>TypedDataset[U]</code> to another of type <code>TypedDataset[T]</code> as long
        as the types in <code>U</code> and <code>T</code> align.</p>
        <p>When the cast is valid the expression compiles:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">UpdatedSurface</span><span>(</span><span class="identifier">city</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">surface</span><span>: </span><span class="type-name">Int</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">updated</span><span> = </span><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>), </span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>) + </span><span class="number-literal">2</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">UpdatedSurface</span><span>]
</span><span class="comment">// updated: TypedDataset[UpdatedSurface] = [city: string, surface: int]
</span><span class="identifier">updated</span><span>.</span><span class="identifier">show</span><span>(</span><span class="number-literal">2</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+-------+
// | city|surface|
// +-----+-------+
// |Paris|     52|
// |Paris|    102|
// +-----+-------+
// only showing top 2 rows
//</span></code></pre>
        <p>Next we try to cast a <code>(String, String)</code> to an <code>UpdatedSurface</code> (which has types <code>String</code>, <code>Int</code>).
        The cast is not valid and the expression does not compile:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>), </span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>)).</span><span class="identifier">as</span><span>[</span><span class="type-name">UpdatedSurface</span><span>]
</span><span class="comment">// error: could not find implicit value for parameter as: frameless.ops.As[(String, String),UpdatedSurface]
// aptTypedDs.select(aptTypedDs(&#39;city), aptTypedDs(&#39;city)).as[UpdatedSurface]
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre>
        
        <h3 id="advanced-topics-with-select" class="section">Advanced topics with <code>select()</code><a class="anchor-link right" href="#advanced-topics-with-select"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>When you <code>select()</code> a single column that has type <code>A</code>, the resulting type is <code>TypedDataset[A]</code> and 
        not <code>TypedDataset[Tuple1[A]]</code>. This behavior makes working with nested schema easier (i.e., in the case 
        where <code>A</code> is a complex data type) and simplifies type-checking column operations (e.g., verify that two 
        columns can be added, divided, etc.). However, when <code>A</code> is scalar, say a <code>Long</code>, it makes it harder to select 
        and work with the resulting <code>TypedDataset[Long]</code>. For instance, it&#39;s harder to reference this single scalar 
        column using <code>select()</code>. If this becomes an issue, you can bypass this behavior by using the 
        <code>selectMany()</code> method instead of <code>select()</code>. In the previous example, <code>selectMany()</code> will return
        <code>TypedDataset[Tuple1[Long]]</code> and you can reference its single column using the name <code>_1</code>. 
        <code>selectMany()</code> should also be used when you need to select more than 10 columns. 
        <code>select()</code> has better IDE support and compiles faster than the macro based <code>selectMany()</code>, 
        so prefer <code>select()</code> for the most common use cases.</p>
        <p>When you are handed a single scalar column TypedDataset (e.g., <code>TypedDataset[Double]</code>) 
        the best way to reference its single column is using the <code>asCol</code> (short for &quot;as a column&quot;) method. 
        This is best shown in the example below. We will see more usages of <code>asCol</code> later in this tutorial.<br></p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">priceBySurfaceUnit</span><span> = </span><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;price</span><span>) / </span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>).</span><span class="identifier">cast</span><span>[</span><span class="type-name">Double</span><span>])
</span><span class="comment">// priceBySurfaceUnit: TypedDataset[Double] = [value: double]
</span><span class="identifier">priceBySurfaceUnit</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">priceBySurfaceUnit</span><span>.</span><span class="identifier">asCol</span><span> * </span><span class="number-literal">2</span><span>).</span><span class="identifier">show</span><span>(</span><span class="number-literal">2</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-------+
// |  value|
// +-------+
// |12000.0|
// | 9000.0|
// +-------+
// only showing top 2 rows
//</span></code></pre>
        
        <h3 id="projections" class="section">Projections<a class="anchor-link right" href="#projections"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>We often want to work with a subset of the fields in a dataset.
        Projections allow us to easily select our fields of interest
        while preserving their initial names and types for extra safety.</p>
        <p>Here is an example using the <code>TypedDataset[Apartment]</code> with an additional column:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">aptds</span><span> = </span><span class="identifier">aptTypedDs</span><span> </span><span class="comment">// For shorter expressions
// aptds: TypedDataset[Apartment] = [city: string, surface: int ... 2 more fields] // For shorter expressions
</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ApartmentDetails</span><span>(</span><span class="identifier">city</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">price</span><span>: </span><span class="type-name">Double</span><span>, </span><span class="identifier">surface</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">ratio</span><span>: </span><span class="type-name">Double</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">aptWithRatio</span><span> =
  </span><span class="identifier">aptds</span><span>.</span><span class="identifier">select</span><span>(
    </span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;city</span><span>),
    </span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;price</span><span>),
    </span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>),
    </span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;price</span><span>) / </span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>).</span><span class="identifier">cast</span><span>[</span><span class="type-name">Double</span><span>]
  ).</span><span class="identifier">as</span><span>[</span><span class="type-name">ApartmentDetails</span><span>]
</span><span class="comment">// aptWithRatio: TypedDataset[ApartmentDetails] = [city: string, price: double ... 2 more fields]</span></code></pre>
        <p>Suppose we only want to work with <code>city</code> and <code>ratio</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">CityInfo</span><span>(</span><span class="identifier">city</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">ratio</span><span>: </span><span class="type-name">Double</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">cityRatio</span><span> = </span><span class="identifier">aptWithRatio</span><span>.</span><span class="identifier">project</span><span>[</span><span class="type-name">CityInfo</span><span>]
</span><span class="comment">// cityRatio: TypedDataset[CityInfo] = [city: string, ratio: double]
</span><span>
</span><span class="identifier">cityRatio</span><span>.</span><span class="identifier">show</span><span>(</span><span class="number-literal">2</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+------+
// | city| ratio|
// +-----+------+
// |Paris|6000.0|
// |Paris|4500.0|
// +-----+------+
// only showing top 2 rows
//</span></code></pre>
        <p>Suppose we only want to work with <code>price</code> and <code>ratio</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">PriceInfo</span><span>(</span><span class="identifier">ratio</span><span>: </span><span class="type-name">Double</span><span>, </span><span class="identifier">price</span><span>: </span><span class="type-name">Double</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">priceInfo</span><span> = </span><span class="identifier">aptWithRatio</span><span>.</span><span class="identifier">project</span><span>[</span><span class="type-name">PriceInfo</span><span>]
</span><span class="comment">// priceInfo: TypedDataset[PriceInfo] = [ratio: double, price: double]
</span><span>
</span><span class="identifier">priceInfo</span><span>.</span><span class="identifier">show</span><span>(</span><span class="number-literal">2</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +------+--------+
// | ratio|   price|
// +------+--------+
// |6000.0|300000.0|
// |4500.0|450000.0|
// +------+--------+
// only showing top 2 rows
//</span></code></pre>
        <p>We see that the order of the fields does not matter as long as the
        names and the corresponding types agree. However, if we make a mistake in
        any of the names and/or their types, then we get a compilation error.</p>
        <p>Say we make a typo in a field name:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">PriceInfo2</span><span>(</span><span class="identifier">ratio</span><span>: </span><span class="type-name">Double</span><span>, </span><span class="identifier">pricEE</span><span>: </span><span class="type-name">Double</span><span>)</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptWithRatio</span><span>.</span><span class="identifier">project</span><span>[</span><span class="type-name">PriceInfo2</span><span>]
</span><span class="comment">// error: Cannot prove that ApartmentDetails can be projected to PriceInfo2. Perhaps not all member names and types of PriceInfo2 are the same in ApartmentDetails?
// aptWithRatio.project[PriceInfo2]
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre>
        <p>Say we make a mistake in the corresponding type:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">PriceInfo3</span><span>(</span><span class="identifier">ratio</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">price</span><span>: </span><span class="type-name">Double</span><span>) </span><span class="comment">// ratio should be Double</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptWithRatio</span><span>.</span><span class="identifier">project</span><span>[</span><span class="type-name">PriceInfo3</span><span>]
</span><span class="comment">// error: Cannot prove that ApartmentDetails can be projected to PriceInfo3. Perhaps not all member names and types of PriceInfo3 are the same in ApartmentDetails?
// aptWithRatio.project[PriceInfo3]
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre>
        
        <h3 id="union-of-typeddatasets" class="section">Union of TypedDatasets<a class="anchor-link right" href="#union-of-typeddatasets"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>Lets create a projection of our original dataset with a subset of the fields.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ApartmentShortInfo</span><span>(</span><span class="identifier">city</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">price</span><span>: </span><span class="type-name">Double</span><span>, </span><span class="identifier">bedrooms</span><span>: </span><span class="type-name">Int</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">aptTypedDs2</span><span>: </span><span class="type-name">TypedDataset</span><span>[</span><span class="type-name">ApartmentShortInfo</span><span>] = </span><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">project</span><span>[</span><span class="type-name">ApartmentShortInfo</span><span>]</span></code></pre>
        <p>The union of <code>aptTypedDs2</code> with <code>aptTypedDs</code> uses all the fields of the caller (<code>aptTypedDs2</code>)
        and expects the other dataset (<code>aptTypedDs</code>) to include all those fields. 
        If field names/types do not match you get a compilation error. </p>
        <pre><code class="nohighlight"><span class="identifier">aptTypedDs2</span><span>.</span><span class="identifier">union</span><span>(</span><span class="identifier">aptTypedDs</span><span>).</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>
</span><span class="comment">// +-----+--------+--------+
// | city|   price|bedrooms|
// +-----+--------+--------+
// |Paris|300000.0|       2|
// |Paris|450000.0|       3|
// |Paris|250000.0|       1|
// | Lyon|200000.0|       2|
// | Lyon|133000.0|       1|
// | Nice|325000.0|       3|
// |Paris|300000.0|       2|
// |Paris|450000.0|       3|
// |Paris|250000.0|       1|
// | Lyon|200000.0|       2|
// | Lyon|133000.0|       1|
// | Nice|325000.0|       3|
// +-----+--------+--------+
//</span></code></pre>
        <p>The other way around will not compile, since <code>aptTypedDs2</code> has only a subset of the fields. </p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">union</span><span>(</span><span class="identifier">aptTypedDs2</span><span>).</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>
</span><span class="comment">// error: Cannot prove that ApartmentShortInfo can be projected to repl.MdocSession.App0.Apartment. Perhaps not all member names and types of repl.MdocSession.App0.Apartment are the same in ApartmentShortInfo?
// Error occurred in an application involving default arguments.
// aptTypedDs.union(aptTypedDs2).show().run
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre>
        <p>Finally, as with <code>project</code>, <code>union</code> will align fields that have same names/types,
        so fields do not have to be in the same order. </p>
        
        <h2 id="typeddataset-functions-and-transformations" class="section">TypedDataset functions and transformations<a class="anchor-link right" href="#typeddataset-functions-and-transformations"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>Frameless supports many of Spark&#39;s functions and transformations. 
        However, whenever a Spark function does not exist in Frameless, 
        calling <code>.dataset</code> will expose the underlying 
        <code>Dataset</code> (from org.apache.spark.sql, the original Spark APIs), 
        where you can use anything that would be missing from the Frameless&#39; API.</p>
        <p>These are the main imports for Frameless&#39; aggregate and non-aggregate functions.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="identifier">functions</span><span>.</span><span class="identifier">_</span><span>                </span><span class="comment">// For literals
</span><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="identifier">functions</span><span>.</span><span class="identifier">nonAggregate</span><span>.</span><span class="identifier">_</span><span>   </span><span class="comment">// e.g., concat, abs
</span><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="identifier">functions</span><span>.</span><span class="identifier">aggregate</span><span>.</span><span class="identifier">_</span><span>      </span><span class="comment">// e.g., count, sum, avg </span></code></pre>
        
        <h3 id="drop-replace-add-fields" class="section">Drop/Replace/Add fields<a class="anchor-link right" href="#drop-replace-add-fields"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p><code>dropTupled()</code> drops a single column and results in a tuple-based schema.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDs2</span><span>.</span><span class="identifier">dropTupled</span><span>(</span><span class="symbol-literal">&#39;price</span><span>): </span><span class="type-name">TypedDataset</span><span>[(</span><span class="type-name">String</span><span>,</span><span class="type-name">Int</span><span>)]
</span><span class="comment">// res18: TypedDataset[(String, Int)] = [_1: string, _2: int]</span></code></pre>
        <p>To drop a column and specify a new schema use <code>drop()</code>.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">CityBeds</span><span>(</span><span class="identifier">city</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">bedrooms</span><span>: </span><span class="type-name">Int</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">cityBeds</span><span>: </span><span class="type-name">TypedDataset</span><span>[</span><span class="type-name">CityBeds</span><span>] = </span><span class="identifier">aptTypedDs2</span><span>.</span><span class="identifier">drop</span><span>[</span><span class="type-name">CityBeds</span><span>] 
</span><span class="comment">// cityBeds: TypedDataset[CityBeds] = [city: string, bedrooms: int]</span></code></pre>
        <p>Often, you want to replace an existing column with a new value.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">inflation</span><span> = </span><span class="identifier">aptTypedDs2</span><span>.</span><span class="identifier">withColumnReplaced</span><span>(</span><span class="symbol-literal">&#39;price</span><span>, </span><span class="identifier">aptTypedDs2</span><span>(</span><span class="symbol-literal">&#39;price</span><span>) * </span><span class="number-literal">2</span><span>)
</span><span class="comment">// inflation: TypedDataset[ApartmentShortInfo] = [city: string, price: double ... 1 more field]
</span><span> 
</span><span class="identifier">inflation</span><span>.</span><span class="identifier">show</span><span>(</span><span class="number-literal">2</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+--------+--------+
// | city|   price|bedrooms|
// +-----+--------+--------+
// |Paris|600000.0|       2|
// |Paris|900000.0|       3|
// +-----+--------+--------+
// only showing top 2 rows
//</span></code></pre>
        <p>Or use a literal instead.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="identifier">functions</span><span>.</span><span class="identifier">lit</span><span>
</span><span class="identifier">aptTypedDs2</span><span>.</span><span class="identifier">withColumnReplaced</span><span>(</span><span class="symbol-literal">&#39;price</span><span>, </span><span class="identifier">lit</span><span>(</span><span class="number-literal">0.001</span><span>)) 
</span><span class="comment">// res20: TypedDataset[ApartmentShortInfo] = [city: string, price: double ... 1 more field]</span></code></pre>
        <p>Adding a column using <code>withColumnTupled()</code> results in a tupled-based schema.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDs2</span><span>.</span><span class="identifier">withColumnTupled</span><span>(</span><span class="identifier">lit</span><span>(</span><span class="type-name">Array</span><span>(</span><span class="string-literal">&quot;a&quot;</span><span>,</span><span class="string-literal">&quot;b&quot;</span><span>,</span><span class="string-literal">&quot;c&quot;</span><span>))).</span><span class="identifier">show</span><span>(</span><span class="number-literal">2</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+--------+---+---------+
// |   _1|      _2| _3|       _4|
// +-----+--------+---+---------+
// |Paris|300000.0|  2|[a, b, c]|
// |Paris|450000.0|  3|[a, b, c]|
// +-----+--------+---+---------+
// only showing top 2 rows
//</span></code></pre>
        <p>Similarly, <code>withColumn()</code> adds a column and explicitly expects a schema for the result.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">CityBedsOther</span><span>(</span><span class="identifier">city</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">bedrooms</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">other</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">String</span><span>])

</span><span class="identifier">cityBeds</span><span>.
   </span><span class="identifier">withColumn</span><span>[</span><span class="type-name">CityBedsOther</span><span>](</span><span class="identifier">lit</span><span>(</span><span class="type-name">List</span><span>(</span><span class="string-literal">&quot;a&quot;</span><span>,</span><span class="string-literal">&quot;b&quot;</span><span>,</span><span class="string-literal">&quot;c&quot;</span><span>))).
   </span><span class="identifier">show</span><span>(</span><span class="number-literal">1</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+--------+---------+
// | city|bedrooms|    other|
// +-----+--------+---------+
// |Paris|       2|[a, b, c]|
// +-----+--------+---------+
// only showing top 1 row
//</span></code></pre>
        <p>To conditionally change a column use the <code>when/otherwise</code> operation. </p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="identifier">functions</span><span>.</span><span class="identifier">nonAggregate</span><span>.</span><span class="identifier">when</span><span>
</span><span class="identifier">aptTypedDs2</span><span>.</span><span class="identifier">withColumnTupled</span><span>(
   </span><span class="identifier">when</span><span>(</span><span class="identifier">aptTypedDs2</span><span>(</span><span class="symbol-literal">&#39;city</span><span>) === </span><span class="string-literal">&quot;Paris&quot;</span><span>, </span><span class="identifier">aptTypedDs2</span><span>(</span><span class="symbol-literal">&#39;price</span><span>)).
   </span><span class="identifier">when</span><span>(</span><span class="identifier">aptTypedDs2</span><span>(</span><span class="symbol-literal">&#39;city</span><span>) === </span><span class="string-literal">&quot;Lyon&quot;</span><span>, </span><span class="identifier">lit</span><span>(</span><span class="number-literal">1.1</span><span>)).
   </span><span class="identifier">otherwise</span><span>(</span><span class="identifier">lit</span><span>(</span><span class="number-literal">0.0</span><span>))).</span><span class="identifier">show</span><span>(</span><span class="number-literal">8</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+--------+---+--------+
// |   _1|      _2| _3|      _4|
// +-----+--------+---+--------+
// |Paris|300000.0|  2|300000.0|
// |Paris|450000.0|  3|450000.0|
// |Paris|250000.0|  1|250000.0|
// | Lyon|200000.0|  2|     1.1|
// | Lyon|133000.0|  1|     1.1|
// | Nice|325000.0|  3|     0.0|
// +-----+--------+---+--------+
//</span></code></pre>
        <p>A simple way to add a column without losing important schema information is
        to project the entire source schema into a single column using the <code>asCol()</code> method.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">c</span><span> = </span><span class="identifier">cityBeds</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">cityBeds</span><span>.</span><span class="identifier">asCol</span><span>, </span><span class="identifier">lit</span><span>(</span><span class="type-name">List</span><span>(</span><span class="string-literal">&quot;a&quot;</span><span>,</span><span class="string-literal">&quot;b&quot;</span><span>,</span><span class="string-literal">&quot;c&quot;</span><span>)))
</span><span class="comment">// c: TypedDataset[(CityBeds, List[String])] = [_1: struct&lt;city: string, bedrooms: int&gt;, _2: array&lt;string&gt;]
</span><span class="identifier">c</span><span>.</span><span class="identifier">show</span><span>(</span><span class="number-literal">1</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +----------+---------+
// |        _1|       _2|
// +----------+---------+
// |{Paris, 2}|[a, b, c]|
// +----------+---------+
// only showing top 1 row
//</span></code></pre>
        <p>When working with Spark&#39;s <code>DataFrames</code>, you often select all columns using <code>.select($&quot;*&quot;, ...)</code>. 
        In a way, <code>asCol()</code> is a typed equivalent of <code>$&quot;*&quot;</code>. </p>
        <p>To access nested columns, use the <code>colMany()</code> method. </p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">c</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">c</span><span>.</span><span class="identifier">colMany</span><span>(&#39;</span><span class="identifier">_1</span><span>, </span><span class="symbol-literal">&#39;city</span><span>), </span><span class="identifier">c</span><span>(&#39;</span><span class="identifier">_2</span><span>)).</span><span class="identifier">show</span><span>(</span><span class="number-literal">2</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+---------+
// |   _1|       _2|
// +-----+---------+
// |Paris|[a, b, c]|
// |Paris|[a, b, c]|
// +-----+---------+
// only showing top 2 rows
//</span></code></pre>
        
        <h3 id="working-with-collections" class="section">Working with collections<a class="anchor-link right" href="#working-with-collections"><i class="icofont-laika">&#xef71;</i></a></h3>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="identifier">functions</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="identifier">functions</span><span>.</span><span class="identifier">nonAggregate</span><span>.</span><span class="identifier">_</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">t</span><span> = </span><span class="identifier">cityRatio</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">cityRatio</span><span>(</span><span class="symbol-literal">&#39;city</span><span>), </span><span class="identifier">lit</span><span>(</span><span class="type-name">List</span><span>(</span><span class="string-literal">&quot;abc&quot;</span><span>,</span><span class="string-literal">&quot;c&quot;</span><span>,</span><span class="string-literal">&quot;d&quot;</span><span>)))
</span><span class="comment">// t: TypedDataset[(String, List[String])] = [_1: string, _2: array&lt;string&gt;]
</span><span class="identifier">t</span><span>.</span><span class="identifier">withColumnTupled</span><span>(
   </span><span class="identifier">arrayContains</span><span>(</span><span class="identifier">t</span><span>(&#39;</span><span class="identifier">_2</span><span>), </span><span class="string-literal">&quot;abc&quot;</span><span>)
).</span><span class="identifier">show</span><span>(</span><span class="number-literal">1</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+-----------+----+
// |   _1|         _2|  _3|
// +-----+-----------+----+
// |Paris|[abc, c, d]|true|
// +-----+-----------+----+
// only showing top 1 row
//</span></code></pre>
        <p>If accidentally you apply a collection function on a column that is not a collection,
        you get a compilation error.</p>
        <pre><code class="nohighlight"><span class="identifier">t</span><span>.</span><span class="identifier">withColumnTupled</span><span>(
   </span><span class="identifier">arrayContains</span><span>(</span><span class="identifier">t</span><span>(&#39;</span><span class="identifier">_1</span><span>), </span><span class="string-literal">&quot;abc&quot;</span><span>)
)
</span><span class="comment">// error: no type parameters for method arrayContains: (column: frameless.AbstractTypedColumn[T,C[A]], value: A)(implicit evidence$1: frameless.CatalystCollection[C])column.ThisType[T,Boolean] exist so that it can be applied to arguments (frameless.TypedColumn[(String, List[String]),String], String)
//  --- because ---
// argument expression&#39;s type is not compatible with formal parameter type;
//  found   : frameless.TypedColumn[(String, List[String]),String]
//  required: frameless.AbstractTypedColumn[?T,?C[?A]]
// 
// Error occurred in an application involving default arguments.
//    arrayContains(t(&#39;_1), &quot;abc&quot;)
//    ^^^^^^^^^^^^^
// error: type mismatch;
//  found   : frameless.TypedColumn[(String, List[String]),String]
//  required: frameless.AbstractTypedColumn[T,C[A]]
// Error occurred in an application involving default arguments.
//    arrayContains(t(&#39;_1), &quot;abc&quot;)
//                  ^^^^^^
// error: type mismatch;
//  found   : String(&quot;abc&quot;)
//  required: A
// Error occurred in an application involving default arguments.
//    arrayContains(t(&#39;_1), &quot;abc&quot;)
//                          ^^^^^
// error: Cannot do collection operations on columns of type C.
// Error occurred in an application involving default arguments.
//    arrayContains(t(&#39;_1), &quot;abc&quot;)
//                 ^</span></code></pre>
        <p>Flattening columns in Spark is done with the <code>explode()</code> method. Unlike vanilla Spark, 
        in Frameless <code>explode()</code> is part of <code>TypedDataset</code> and not a function of a column. 
        This provides additional safety since more than one <code>explode()</code> applied in a single 
        statement results in runtime error in vanilla Spark. <br></p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">t2</span><span> = </span><span class="identifier">cityRatio</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">cityRatio</span><span>(</span><span class="symbol-literal">&#39;city</span><span>), </span><span class="identifier">lit</span><span>(</span><span class="type-name">List</span><span>(</span><span class="number-literal">1</span><span>,</span><span class="number-literal">2</span><span>,</span><span class="number-literal">3</span><span>,</span><span class="number-literal">4</span><span>)))
</span><span class="comment">// t2: TypedDataset[(String, List[Int])] = [_1: string, _2: array&lt;int&gt;]
</span><span class="keyword">val</span><span> </span><span class="identifier">flattened</span><span> = </span><span class="identifier">t2</span><span>.</span><span class="identifier">explode</span><span>(&#39;</span><span class="identifier">_2</span><span>): </span><span class="type-name">TypedDataset</span><span>[(</span><span class="type-name">String</span><span>, </span><span class="type-name">Int</span><span>)]
</span><span class="comment">// flattened: TypedDataset[(String, Int)] = [_1: string, _2: int]
</span><span class="identifier">flattened</span><span>.</span><span class="identifier">show</span><span>(</span><span class="number-literal">4</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+---+
// |   _1| _2|
// +-----+---+
// |Paris|  1|
// |Paris|  2|
// |Paris|  3|
// |Paris|  4|
// +-----+---+
// only showing top 4 rows
//</span></code></pre>
        <p>Here is an example of how <code>explode()</code> may fail in vanilla Spark. The Frameless 
        implementation does not suffer from this problem since, by design, it can only be applied
        to a single column at a time. </p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span>{
  </span><span class="keyword">import</span><span> </span><span class="identifier">org</span><span>.</span><span class="identifier">apache</span><span>.</span><span class="identifier">spark</span><span>.</span><span class="identifier">sql</span><span>.</span><span class="identifier">functions</span><span>.{</span><span class="identifier">explode</span><span> =&gt; </span><span class="identifier">sparkExplode</span><span>}
  </span><span class="identifier">t2</span><span>.</span><span class="identifier">dataset</span><span>.</span><span class="identifier">toDF</span><span>().</span><span class="identifier">select</span><span>(</span><span class="identifier">sparkExplode</span><span>(</span><span class="identifier">$</span><span class="string-literal">&quot;_2&quot;</span><span>), </span><span class="identifier">sparkExplode</span><span>(</span><span class="identifier">$</span><span class="string-literal">&quot;_2&quot;</span><span>))
}
</span><span class="comment">// error: Unit does not take parameters
// Error occurred in an application involving default arguments.
// flattened.show(4).run()
// ^^^^^^^^^^^^^</span></code></pre>
        
        <h3 id="collecting-data-to-the-driver" class="section">Collecting data to the driver<a class="anchor-link right" href="#collecting-data-to-the-driver"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>In Frameless all Spark actions (such as <code>collect()</code>) are safe.</p>
        <p>Take the first element from a dataset (if the dataset is empty return <code>None</code>).</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">cityBeds</span><span>.</span><span class="identifier">headOption</span><span>.</span><span class="identifier">run</span><span>()
</span><span class="comment">// res30: Option[CityBeds] = Some(CityBeds(&quot;Paris&quot;, 2))</span></code></pre>
        <p>Take the first <code>n</code> elements.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">cityBeds</span><span>.</span><span class="identifier">take</span><span>(</span><span class="number-literal">2</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// res31: Seq[CityBeds] = WrappedArray(
//   CityBeds(&quot;Paris&quot;, 2),
//   CityBeds(&quot;Paris&quot;, 3)
// )</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">cityBeds</span><span>.</span><span class="identifier">head</span><span>(</span><span class="number-literal">3</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// res32: Seq[CityBeds] = WrappedArray(
//   CityBeds(&quot;Paris&quot;, 2),
//   CityBeds(&quot;Paris&quot;, 3),
//   CityBeds(&quot;Paris&quot;, 1)
// )</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">cityBeds</span><span>.</span><span class="identifier">limit</span><span>(</span><span class="number-literal">4</span><span>).</span><span class="identifier">collect</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// res33: Seq[CityBeds] = WrappedArray(
//   CityBeds(&quot;Paris&quot;, 2),
//   CityBeds(&quot;Paris&quot;, 3),
//   CityBeds(&quot;Paris&quot;, 1),
//   CityBeds(&quot;Lyon&quot;, 2)
// )</span></code></pre>
        
        <h2 id="sorting-columns" class="section">Sorting columns<a class="anchor-link right" href="#sorting-columns"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>Only column types that can be sorted are allowed to be selected for sorting. </p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">orderBy</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>).</span><span class="identifier">asc</span><span>).</span><span class="identifier">show</span><span>(</span><span class="number-literal">2</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +----+-------+--------+--------+
// |city|surface|   price|bedrooms|
// +----+-------+--------+--------+
// |Lyon|     45|133000.0|       1|
// |Lyon|     83|200000.0|       2|
// +----+-------+--------+--------+
// only showing top 2 rows
//</span></code></pre>
        <p>The ordering can be changed by selecting <code>.acs</code> or <code>.desc</code>. </p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">orderBy</span><span>(
   </span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>).</span><span class="identifier">asc</span><span>, 
   </span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;price</span><span>).</span><span class="identifier">desc</span><span>
).</span><span class="identifier">show</span><span>(</span><span class="number-literal">2</span><span>).</span><span class="identifier">run</span><span>()
</span><span class="comment">// +----+-------+--------+--------+
// |city|surface|   price|bedrooms|
// +----+-------+--------+--------+
// |Lyon|     83|200000.0|       2|
// |Lyon|     45|133000.0|       1|
// +----+-------+--------+--------+
// only showing top 2 rows
//</span></code></pre>
        
        <h2 id="user-defined-functions" class="section">User Defined Functions<a class="anchor-link right" href="#user-defined-functions"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>Frameless supports lifting any Scala function (up to five arguments) to the
        context of a particular <code>TypedDataset</code>:</p>
        <pre><code class="nohighlight"><span class="comment">// The function we want to use as UDF
</span><span class="keyword">val</span><span> </span><span class="identifier">priceModifier</span><span> =
    (</span><span class="identifier">name</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">price</span><span>:</span><span class="type-name">Double</span><span>) =&gt; </span><span class="keyword">if</span><span>(</span><span class="identifier">name</span><span> == </span><span class="string-literal">&quot;Paris&quot;</span><span>) </span><span class="identifier">price</span><span> * </span><span class="number-literal">2.0</span><span> </span><span class="keyword">else</span><span> </span><span class="identifier">price</span><span>
</span><span class="comment">// priceModifier: (String, Double) =&gt; Double = &lt;function2&gt;
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">udf</span><span> = </span><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">makeUDF</span><span>(</span><span class="identifier">priceModifier</span><span>)
</span><span class="comment">// udf: (frameless.TypedColumn[Apartment, String], frameless.TypedColumn[Apartment, Double]) =&gt; frameless.TypedColumn[Apartment, Double] = frameless.functions.Udf$$Lambda$15389/1106189748@7fb32a98
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">aptds</span><span> = </span><span class="identifier">aptTypedDs</span><span> </span><span class="comment">// For shorter expressions
// aptds: TypedDataset[Apartment] = [city: string, surface: int ... 2 more fields] // For shorter expressions
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">adjustedPrice</span><span> = </span><span class="identifier">aptds</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;city</span><span>), </span><span class="identifier">udf</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;city</span><span>), </span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;price</span><span>)))
</span><span class="comment">// adjustedPrice: TypedDataset[(String, Double)] = [_1: string, _2: double]
</span><span>
</span><span class="identifier">adjustedPrice</span><span>.</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+--------+
// |   _1|      _2|
// +-----+--------+
// |Paris|600000.0|
// |Paris|900000.0|
// |Paris|500000.0|
// | Lyon|200000.0|
// | Lyon|133000.0|
// | Nice|325000.0|
// +-----+--------+
//</span></code></pre>
        
        <h2 id="groupby-and-aggregations" class="section">GroupBy and Aggregations<a class="anchor-link right" href="#groupby-and-aggregations"><i class="icofont-laika">&#xef71;</i></a></h2>
        <p>Let&#39;s suppose we wanted to retrieve the average apartment price in each city</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">priceByCity</span><span> = </span><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">groupBy</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>)).</span><span class="identifier">agg</span><span>(</span><span class="identifier">avg</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;price</span><span>)))
</span><span class="comment">// priceByCity: TypedDataset[(String, Double)] = [_1: string, _2: double]
</span><span class="identifier">priceByCity</span><span>.</span><span class="identifier">collect</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// res37: Seq[(String, Double)] = WrappedArray(
//   (&quot;Paris&quot;, 333333.3333333333),
//   (&quot;Nice&quot;, 325000.0),
//   (&quot;Lyon&quot;, 166500.0)
// )</span></code></pre>
        <p>Again if we try to aggregate a column that can&#39;t be aggregated, we get a compilation error</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">groupBy</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>)).</span><span class="identifier">agg</span><span>(</span><span class="identifier">avg</span><span>(</span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>)))
</span><span class="comment">// error: Cannot compute average of type String.
// Error occurred in an application involving default arguments.
// aptTypedDs.groupBy(aptTypedDs(&#39;city)).agg(avg(aptTypedDs(&#39;city)))
//                                              ^</span></code></pre>
        <p>Next, we combine <code>select</code> and <code>groupBy</code> to calculate the average price/surface ratio per city:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">aptds</span><span> = </span><span class="identifier">aptTypedDs</span><span> </span><span class="comment">// For shorter expressions
// aptds: TypedDataset[Apartment] = [city: string, surface: int ... 2 more fields] // For shorter expressions
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">cityPriceRatio</span><span> =  </span><span class="identifier">aptds</span><span>.</span><span class="identifier">select</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;city</span><span>), </span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;price</span><span>) / </span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>).</span><span class="identifier">cast</span><span>[</span><span class="type-name">Double</span><span>])
</span><span class="comment">// cityPriceRatio: TypedDataset[(String, Double)] = [_1: string, _2: double]
</span><span>
</span><span class="identifier">cityPriceRatio</span><span>.</span><span class="identifier">groupBy</span><span>(</span><span class="identifier">cityPriceRatio</span><span>(&#39;</span><span class="identifier">_1</span><span>)).</span><span class="identifier">agg</span><span>(</span><span class="identifier">avg</span><span>(</span><span class="identifier">cityPriceRatio</span><span>(&#39;</span><span class="identifier">_2</span><span>))).</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+------------------+
// |   _1|                _2|
// +-----+------------------+
// |Paris| 6833.333333333333|
// | Nice| 4391.891891891892|
// | Lyon|2682.5970548862115|
// +-----+------------------+
//</span></code></pre>
        <p>We can also use <code>pivot</code> to further group data on a secondary column.
        For example, we can compare the average price across cities by number of bedrooms.</p>
        <pre><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">BedroomStats</span><span>(
   </span><span class="identifier">city</span><span>: </span><span class="type-name">String</span><span>,
   </span><span class="type-name">AvgPriceBeds1</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">Double</span><span>], </span><span class="comment">// Pivot values may be missing, so we encode them using Options
</span><span>   </span><span class="type-name">AvgPriceBeds2</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">Double</span><span>],
   </span><span class="type-name">AvgPriceBeds3</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">Double</span><span>],
   </span><span class="type-name">AvgPriceBeds4</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">Double</span><span>])

</span><span class="keyword">val</span><span> </span><span class="identifier">bedroomStats</span><span> = </span><span class="identifier">aptds</span><span>.
   </span><span class="identifier">groupBy</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;city</span><span>)).
   </span><span class="identifier">pivot</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;bedrooms</span><span>)).
   </span><span class="identifier">on</span><span>(</span><span class="number-literal">1</span><span>,</span><span class="number-literal">2</span><span>,</span><span class="number-literal">3</span><span>,</span><span class="number-literal">4</span><span>). </span><span class="comment">// We only care for up to 4 bedrooms
</span><span>   </span><span class="identifier">agg</span><span>(</span><span class="identifier">avg</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;price</span><span>))).
   </span><span class="identifier">as</span><span>[</span><span class="type-name">BedroomStats</span><span>]  </span><span class="comment">// Typesafe casting
// bedroomStats: TypedDataset[BedroomStats] = [city: string, AvgPriceBeds1: double ... 3 more fields]  // Typesafe casting
</span><span>
</span><span class="identifier">bedroomStats</span><span>.</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----+-------------+-------------+-------------+-------------+
// | city|AvgPriceBeds1|AvgPriceBeds2|AvgPriceBeds3|AvgPriceBeds4|
// +-----+-------------+-------------+-------------+-------------+
// | Nice|         null|         null|     325000.0|         null|
// |Paris|     250000.0|     300000.0|     450000.0|         null|
// | Lyon|     133000.0|     200000.0|         null|         null|
// +-----+-------------+-------------+-------------+-------------+
//</span></code></pre>
        <p>With pivot, collecting data preserves typesafety by
        encoding potentially missing columns with <code>Option</code>.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">bedroomStats</span><span>.</span><span class="identifier">collect</span><span>().</span><span class="identifier">run</span><span>().</span><span class="identifier">foreach</span><span>(</span><span class="identifier">println</span><span>)
</span><span class="comment">// BedroomStats(Nice,None,None,Some(325000.0),None)
// BedroomStats(Paris,Some(250000.0),Some(300000.0),Some(450000.0),None)
// BedroomStats(Lyon,Some(133000.0),Some(200000.0),None,None)</span></code></pre>
        
        <h4 id="working-with-optional-fields" class="section">Working with Optional fields<a class="anchor-link right" href="#working-with-optional-fields"><i class="icofont-laika">&#xef71;</i></a></h4>
        <p>Optional fields can be converted to non-optional using <code>getOrElse()</code>. </p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">sampleStats</span><span> = </span><span class="identifier">bedroomStats</span><span>.</span><span class="identifier">select</span><span>(
   </span><span class="identifier">bedroomStats</span><span>(</span><span class="symbol-literal">&#39;AvgPriceBeds2</span><span>).</span><span class="identifier">getOrElse</span><span>(</span><span class="number-literal">0.0</span><span>),
   </span><span class="identifier">bedroomStats</span><span>(</span><span class="symbol-literal">&#39;AvgPriceBeds3</span><span>).</span><span class="identifier">getOrElse</span><span>(</span><span class="number-literal">0.0</span><span>))
</span><span class="comment">// sampleStats: TypedDataset[(Double, Double)] = [_1: double, _2: double]
</span><span>
</span><span class="identifier">sampleStats</span><span>.</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()   
</span><span class="comment">// +--------+--------+
// |      _1|      _2|
// +--------+--------+
// |     0.0|325000.0|
// |300000.0|450000.0|
// |200000.0|     0.0|
// +--------+--------+
//</span></code></pre>
        <p>In addition, optional columns can be flatten using the <code>.flattenOption</code> method on <code>TypedDatset</code>.
        The result contains the rows for which the flattened column is not None (or null). The schema
        is automatically adapted to reflect this change.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">flattenStats</span><span> = </span><span class="identifier">bedroomStats</span><span>.</span><span class="identifier">flattenOption</span><span>(</span><span class="symbol-literal">&#39;AvgPriceBeds2</span><span>)
</span><span class="comment">// flattenStats: TypedDataset[(String, Option[Double], Double, Option[Double], Option[Double])] = [_1: string, _2: double ... 3 more fields]
</span><span>

</span><span class="comment">// The second Option[Double] is now of type Double, since all &#39;null&#39; values are removed
</span><span class="identifier">flattenStats</span><span>: </span><span class="type-name">TypedDataset</span><span>[(</span><span class="type-name">String</span><span>, </span><span class="type-name">Option</span><span>[</span><span class="type-name">Double</span><span>], </span><span class="type-name">Double</span><span>, </span><span class="type-name">Option</span><span>[</span><span class="type-name">Double</span><span>], </span><span class="type-name">Option</span><span>[</span><span class="type-name">Double</span><span>])]
</span><span class="comment">// res43: TypedDataset[(String, Option[Double], Double, Option[Double], Option[Double])] = [_1: string, _2: double ... 3 more fields]</span></code></pre>
        <p>In a DataFrame, if you just ignore types, this would equivelantly be written as:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">bedroomStats</span><span>.</span><span class="identifier">dataset</span><span>.</span><span class="identifier">toDF</span><span>().</span><span class="identifier">filter</span><span>(</span><span class="identifier">$</span><span class="string-literal">&quot;AvgPriceBeds2&quot;</span><span>.</span><span class="identifier">isNotNull</span><span>)
</span><span class="comment">// res44: org.apache.spark.sql.Dataset[org.apache.spark.sql.Row] = [city: string, AvgPriceBeds1: double ... 3 more fields]</span></code></pre>
        
        <h3 id="entire-typeddataset-aggregation" class="section">Entire TypedDataset Aggregation<a class="anchor-link right" href="#entire-typeddataset-aggregation"><i class="icofont-laika">&#xef71;</i></a></h3>
        <p>We often want to aggregate the entire <code>TypedDataset</code> and skip the <code>groupBy()</code> clause.
        In Frameless you can do this using the <code>agg()</code> operator directly on the <code>TypedDataset</code>.
        In the following example, we compute the average price, the average surface,
        the minimum surface, and the set of cities for the entire dataset.</p>
        <pre><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Stats</span><span>(
   </span><span class="identifier">avgPrice</span><span>: </span><span class="type-name">Double</span><span>,
   </span><span class="identifier">avgSurface</span><span>: </span><span class="type-name">Double</span><span>,
   </span><span class="identifier">minSurface</span><span>: </span><span class="type-name">Int</span><span>,
   </span><span class="identifier">allCities</span><span>: </span><span class="type-name">Vector</span><span>[</span><span class="type-name">String</span><span>])

</span><span class="identifier">aptds</span><span>.</span><span class="identifier">agg</span><span>(
   </span><span class="identifier">avg</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;price</span><span>)),
   </span><span class="identifier">avg</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>)),
   </span><span class="identifier">min</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>)),
   </span><span class="identifier">collectSet</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;city</span><span>))
).</span><span class="identifier">as</span><span>[</span><span class="type-name">Stats</span><span>].</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----------------+------------------+----------+-------------------+
// |         avgPrice|        avgSurface|minSurface|          allCities|
// +-----------------+------------------+----------+-------------------+
// |276333.3333333333|62.833333333333336|        25|[Paris, Nice, Lyon]|
// +-----------------+------------------+----------+-------------------+
//</span></code></pre>
        <p>You may apply any <code>TypedColumn</code> operation to a <code>TypedAggregate</code> column as well.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">frameless</span><span>.</span><span class="identifier">functions</span><span>.</span><span class="identifier">_</span><span>
</span><span class="identifier">aptds</span><span>.</span><span class="identifier">agg</span><span>(
   </span><span class="identifier">avg</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;price</span><span>)) * </span><span class="identifier">min</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>)).</span><span class="identifier">cast</span><span>[</span><span class="type-name">Double</span><span>], 
   </span><span class="identifier">avg</span><span>(</span><span class="identifier">aptds</span><span>(</span><span class="symbol-literal">&#39;surface</span><span>)) * </span><span class="number-literal">0.2</span><span>,
   </span><span class="identifier">litAggr</span><span>(</span><span class="string-literal">&quot;Hello World&quot;</span><span>)
).</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// +-----------------+------------------+-----------+
// |               _1|                _2|         _3|
// +-----------------+------------------+-----------+
// |6908333.333333333|12.566666666666668|Hello World|
// +-----------------+------------------+-----------+
//</span></code></pre>
        
        <h2 id="joins" class="section">Joins<a class="anchor-link right" href="#joins"><i class="icofont-laika">&#xef71;</i></a></h2>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">CityPopulationInfo</span><span>(</span><span class="identifier">name</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">population</span><span>: </span><span class="type-name">Int</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">cityInfo</span><span> = </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">CityPopulationInfo</span><span>(</span><span class="string-literal">&quot;Paris&quot;</span><span>, </span><span class="number-literal">2229621</span><span>),
  </span><span class="type-name">CityPopulationInfo</span><span>(</span><span class="string-literal">&quot;Lyon&quot;</span><span>, </span><span class="number-literal">500715</span><span>),
  </span><span class="type-name">CityPopulationInfo</span><span>(</span><span class="string-literal">&quot;Nice&quot;</span><span>, </span><span class="number-literal">343629</span><span>)
)

</span><span class="keyword">val</span><span> </span><span class="identifier">citiInfoTypedDS</span><span> = </span><span class="type-name">TypedDataset</span><span>.</span><span class="identifier">create</span><span>(</span><span class="identifier">cityInfo</span><span>)</span></code></pre>
        <p>Here is how to join the population information to the apartment&#39;s dataset:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">withCityInfo</span><span> = </span><span class="identifier">aptTypedDs</span><span>.</span><span class="identifier">joinInner</span><span>(</span><span class="identifier">citiInfoTypedDS</span><span>) { </span><span class="identifier">aptTypedDs</span><span>(</span><span class="symbol-literal">&#39;city</span><span>) === </span><span class="identifier">citiInfoTypedDS</span><span>(</span><span class="symbol-literal">&#39;name</span><span>) }
</span><span class="comment">// withCityInfo: TypedDataset[(Apartment, CityPopulationInfo)] = [_1: struct&lt;city: string, surface: int ... 2 more fields&gt;, _2: struct&lt;name: string, population: int&gt;]
</span><span>
</span><span class="identifier">withCityInfo</span><span>.</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>()
</span><span class="comment">// +--------------------+----------------+
// |                  _1|              _2|
// +--------------------+----------------+
// |{Paris, 50, 30000...|{Paris, 2229621}|
// |{Paris, 100, 4500...|{Paris, 2229621}|
// |{Paris, 25, 25000...|{Paris, 2229621}|
// |{Lyon, 83, 200000...|  {Lyon, 500715}|
// |{Lyon, 45, 133000...|  {Lyon, 500715}|
// |{Nice, 74, 325000...|  {Nice, 343629}|
// +--------------------+----------------+
//</span></code></pre>
        <p>The joined TypedDataset has type <code>TypedDataset[(Apartment, CityPopulationInfo)]</code>.</p>
        <p>We can then select which information we want to continue to work with:</p>
        <pre><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">AptPriceCity</span><span>(</span><span class="identifier">city</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">aptPrice</span><span>: </span><span class="type-name">Double</span><span>, </span><span class="identifier">cityPopulation</span><span>: </span><span class="type-name">Int</span><span>)

</span><span class="identifier">withCityInfo</span><span>.</span><span class="identifier">select</span><span>(
   </span><span class="identifier">withCityInfo</span><span>.</span><span class="identifier">colMany</span><span>(&#39;</span><span class="identifier">_2</span><span>, </span><span class="symbol-literal">&#39;name</span><span>), </span><span class="identifier">withCityInfo</span><span>.</span><span class="identifier">colMany</span><span>(&#39;</span><span class="identifier">_1</span><span>, </span><span class="symbol-literal">&#39;price</span><span>), </span><span class="identifier">withCityInfo</span><span>.</span><span class="identifier">colMany</span><span>(&#39;</span><span class="identifier">_2</span><span>, </span><span class="symbol-literal">&#39;population</span><span>)
).</span><span class="identifier">as</span><span>[</span><span class="type-name">AptPriceCity</span><span>].</span><span class="identifier">show</span><span>().</span><span class="identifier">run</span><span>
</span><span class="comment">// +-----+--------+--------------+
// | city|aptPrice|cityPopulation|
// +-----+--------+--------------+
// |Paris|300000.0|       2229621|
// |Paris|450000.0|       2229621|
// |Paris|250000.0|       2229621|
// | Lyon|200000.0|        500715|
// | Lyon|133000.0|        500715|
// | Nice|325000.0|        343629|
// +-----+--------+--------------+
//</span></code></pre>

      </main>

    </div>

  </body>
</html>